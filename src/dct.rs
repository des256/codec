use {
    crate::*,
};

/*
    forward: X = (C x trans(C)) * E

    inverse: x = trans(C) (X * E) C

    with:
            1  1  1  1
            2  1 -1 -2
        C = 1 -1 -1  1
            1 -2  2 -1

            aa    ab/2  aa    ab/2
            ab/2  bb/4  ab/2  bb/4
        E = aa    ab/2  aa    ab/2
            ab/2  bb/4  ab/2  bb/4

    with:
        a = 1/2
        b = sqrt(2/5)

    * = element-wise scaling

    and E goes in the quantization stage instead
*/

fn dct(x: [i32; 16]) -> [i32; 16] {

    /*
        1  1  1  1   x     x+y+z+w
        2  1 -1 -2   y     2x+y-z-2w
        1 -1 -1  1   z  =  x-y-z+w
        1 -2  2 -1   w     x-2y+2z-w

        one step:

        p = x+w
        q = y+z
        r = x-w
        s = y-z

        X = p+q
        Y = 2r+s
        Z = p-q
        W = r-2s
    */

    let a = [
        x[0] + x[3],
        x[1] + x[2],
        x[0] - x[3],
        x[1] - x[2],
        x[4] + x[7],
        x[5] + x[6],
        x[4] - x[7],
        x[5] - x[6],
        x[8] + x[11],
        x[9] + x[10],
        x[8] - x[11],
        x[9] - x[10],
        x[12] + x[15],
        x[13] + x[14],
        x[12] - x[15],
        x[13] - x[14],
    ];

    let b = [
        a[0] + a[1],
        2 * a[2] + a[3],
        a[0] - a[1],
        a[2] - 2 * a[3],
        a[4] + a[5],
        2 * a[6] + a[7],
        a[4] - a[5],
        a[6] - 2 * a[7],
        a[8] + a[9],
        2 * a[10] + a[11],
        a[8] - a[9],
        a[10] - 2 * a[11],
        a[12] + a[13],
        2 * a[14] + a[15],
        a[12] - a[13],
        a[14] - 2 * a[15],
    ];

    let c = [
        x[0] + x[12],
        x[1] + x[13],
        x[2] + x[14],
        x[3] + x[15],
        x[4] + x[8],
        x[5] + x[9],
        x[6] + x[10],
        x[7] + x[11],
        x[0] - x[12],
        x[1] - x[13],
        x[2] - x[14],
        x[3] - x[15],
        x[4] - x[8],
        x[5] - x[9],
        x[6] - x[10],
        x[7] - x[11],
    ];

    [
        a[0] + a[4],
        a[1] + a[5],
        a[2] + a[6],
        a[3] + a[7],
        2 * a[8] + a[12],
        2 * a[9] + a[13],
        2 * a[10] + a[14],
        2 * a[11] + a[15],
        a[0] - a[4],
        a[1] - a[5],
        a[2] - a[6],
        a[3] - a[7],
        a[8] - 2 * a[12],
        a[9] - 2 * a[13],
        a[10] - 2 * a[14],
        a[11] - 2 * a[15],
    ]
}

fn idct(x: [i32; 16]) -> [i32; 16] {
    
    /*
        1   1    1   0.5   x     x+y+z+w/2
        1   0.5 -1  -1     y     x+y/2-z-w
        1  -0.5 -1   1     z  =  x-y/2-z+w
        1  -1    1  -0.5   w     x-y+z-w/2

        one step:

        p = x+z
        q = y+w/2
        r = x-z
        s = y/2-w

        X = p+q
        Y = r+s
        Z = r-s
        W = p-q
    */

    let a = [
        x[0] + x[2],
        x[1] + x[3] / 2,
        x[0] - x[2],
        x[1] / 2 - x[3],
        x[4] + x[6],
        x[5] + x[7] / 2,
        x[4] - x[6],
        x[5] / 2 - x[7],
        x[8] + x[10],
        x[9] + x[11] / 2,
        x[8] - x[10],
        x[9] / 2 - x[11],
        x[12] + x[14],
        x[13] + x[15] / 2,
        x[12] - x[14],
        x[13] / 2 - x[15],
    ];

    let b = [
        a[0] + a[1],
        a[2] + a[3],
        a[2] - a[3],
        a[0] - a[1],
        a[4] + a[5],
        a[6] + a[7],
        a[6] - a[7],
        a[4] - a[5],
        a[8] + a[9],
        a[10] + a[11],
        a[10] - a[11],
        a[8] - a[9],
        a[12] + a[13],
        a[14] + a[15],
        a[14] - a[15],
        a[12] - a[13],
    ];

    let c = [
        x[0] + x[8],
        x[1] + x[9],
        x[2] + x[10],
        x[3] + x[11],
        x[4] + x[12] / 2,
        x[5] + x[13] / 2,
        x[6] + x[14] / 2,
        x[7] + x[15] / 2,
        x[0] - x[8],
        x[1] - x[9],
        x[2] - x[10],
        x[3] - x[11],
        x[4] / 2 - x[12],
        x[5] / 2 - x[13],
        x[6] / 2 - x[14],
        x[7] / 2 - x[15],
    ];

    [
        a[0] + a[4],
        a[1] + a[5],
        a[2] + a[6],
        a[3] + a[7],
        a[4] + a[12],
        a[5] + a[13],
        a[6] + a[14],
        a[7] + a[15],
        a[8] - a[12],
        a[9] - a[13],
        a[10] - a[14],
        a[11] - a[15],
        a[0] - a[4],
        a[1] - a[5],
        a[2] - a[6],
        a[3] - a[7],
    ]
}
